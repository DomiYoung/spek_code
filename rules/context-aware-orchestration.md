# Context-Aware Orchestration

> Context Engineering 作为 Spec-Kit 的底层支撑层，而非替代品。
> 权重系统 + 决策卡片 = 对抗衰减的锚点，Context Engineering = 解释为什么有效 + 长对话优化。

---

## 架构关系

```
┌─────────────────────────────────────────────────────────────────┐
│                    用户任务输入                                   │
└─────────────────────────────────┬───────────────────────────────┘
                                  ▼
┌─────────────────────────────────────────────────────────────────┐
│  Layer 1: Workflow Orchestrator（工作流编排层）                   │
│  ├── 权重评估 → 决策卡片输出（锚点机制）                           │
│  ├── Forced Eval Protocol（承诺机制）                            │
│  └── Skill 路由                                                  │
├─────────────────────────────────────────────────────────────────┤
│  Layer 2: Spec-Kit 执行层                                        │
│  ├── speckit.constitution → specify → plan → tasks → implement  │
│  ├── SESSION.md 进度追踪                                         │
│  └── 知识进化写入                                                 │
├─────────────────────────────────────────────────────────────────┤
│  Layer 3: Context Engineering 底层支撑（本规则）                  │
│  ├── 上下文监控 → 退化检测 → 主动干预                             │
│  ├── 长对话压缩 → 保留锚点                                        │
│  └── Sub-agent 隔离建议                                          │
└─────────────────────────────────────────────────────────────────┘
```

---

## 核心原则：为什么你的设计有效

### 决策卡片 = 锚定摘要结构

```
"If it's not in the output, it won't stay in context."
如果不在输出中，就不会留在上下文；不在上下文，就会被遗忘。
```

| 你的设计 | Context Engineering 原理 |
|---------|-------------------------|
| 每次任务输出决策卡片 | **锚定摘要** - 结构化输出强制保留关键信息 |
| Forced Eval YES/NO | **承诺机制** - 显式写入形成不可忽略的锚点 |
| 权重表格勾选 | **检查清单效应** - 专用章节防止静默信息漂移 |
| SESSION.md | **外部记忆** - 文件系统作为持久化上下文 |

### 为什么强制输出比"按需加载"更适合你的场景

```
按需加载适合：信息查询型任务（搜索、RAG）
强制输出适合：流程遵循型任务（你的场景）

原因：
- 流程遵循需要"递归强化"防止衰减
- 决策卡片是低成本高收益的锚点（~200 tokens）
- 跳过一次 = 后续全部失控的风险
```

---

## 集成点 1：上下文监控与退化检测

### 触发时机

在 **workflow-orchestrator** 的 Step 1 之前，增加上下文健康检查：

```
任务开始
    │
    ▼
┌─────────────────────────────────┐
│ Step 0: 上下文健康检查（新增）    │
│ ├── 当前对话轮次 > 20？          │
│ ├── 估算 token 使用 > 50K？      │
│ └── 检测到退化信号？             │
└─────────────────┬───────────────┘
                  │
       ┌──────────┴──────────┐
       ▼                      ▼
   ┌────────┐            ┌────────┐
   │ 健康   │            │ 需干预  │
   └────┬───┘            └────┬───┘
        │                      │
        ▼                      ▼
  ┌───────────────┐    ┌───────────────┐
  │ 继续正常流程   │    │ 触发压缩协议  │
  │ → Step 1 权重  │    │ → 然后 Step 1 │
  └───────────────┘    └───────────────┘
```

### 退化信号检测

| 信号 | 检测方式 | 严重度 |
|------|----------|--------|
| 忘记之前决策 | 重复询问已回答的问题 | 🔴 高 |
| 工具调用错误增加 | 参数错误、调用错工具 | 🔴 高 |
| 跳过决策卡片 | 直接执行未经评估 | 🟡 中 |
| 响应变短/变模糊 | 丧失细节和具体性 | 🟡 中 |
| 混淆任务边界 | 把不同任务内容混在一起 | 🟡 中 |

### 退化检测输出格式

```
╔════════════════════════════════════════════════════════╗
║  ⚠️ 上下文健康检查                                      ║
╠════════════════════════════════════════════════════════╣
║  对话轮次: [N]                                          ║
║  估算 Token: ~[X]K                                      ║
║  退化信号: [无 / 轻微 / 明显]                            ║
║  ────────────────────────────────────────────────────  ║
║  建议动作: [继续 / 压缩历史 / 建议新会话]                ║
╚════════════════════════════════════════════════════════╝
```

---

## 集成点 2：长对话压缩协议

### 何时触发

| 条件 | 动作 |
|------|------|
| 对话轮次 > 30 | 提示用户可压缩 |
| 估算 token > 70K | 自动触发压缩 |
| 检测到退化信号 | 强制触发压缩 |

### 压缩时必须保留的锚点

```yaml
必须保留（永不压缩）:
  - 最近一次决策卡片
  - 当前任务的权重评估结果
  - SESSION.md 中的目标锚点
  - 未完成的 TODO 项
  - 最近 3 轮对话

可以压缩:
  - 早期探索性对话
  - 已完成任务的详细过程
  - 工具输出的完整内容（保留摘要）
  - 重复的解释说明
```

### 压缩输出格式（锚定迭代摘要）

```markdown
## 会话压缩摘要

### 当前任务状态
- 任务: [描述]
- 权重: [X] → 工作流: [Spec-Kit/planning/TodoWrite]
- 进度: [X]%

### 关键决策记录
1. [决策1]: [选择] - 理由: [...]
2. [决策2]: [选择] - 理由: [...]

### 已完成工作
- [x] [工作项1]
- [x] [工作项2]

### 待完成工作
- [ ] [工作项3]
- [ ] [工作项4]

### 活跃文件
- `path/to/file1.ts`: [修改内容摘要]
- `path/to/file2.ts`: [修改内容摘要]

---
[压缩于 YYYY-MM-DD HH:MM，原对话 N 轮]
```

---

## 集成点 3：Spec-Kit 阶段性压缩点

### 在 Spec-Kit 流程中的自然压缩时机

```
speckit.specify 完成
    │
    ▼ ← 压缩点 1：探索性对话可压缩，保留 spec.md
    │
speckit.plan 完成
    │
    ▼ ← 压缩点 2：规划讨论可压缩，保留 implementation_plan.md
    │
speckit.tasks 完成
    │
    ▼ ← 压缩点 3：任务拆分讨论可压缩，保留 tasks 列表
    │
speckit.implement 执行中
    │
    ▼ ← 每完成一个子任务，可压缩该子任务详细过程
```

### 阶段切换时的压缩动作

```
╔════════════════════════════════════════════════════════╗
║  📦 阶段切换压缩                                        ║
╠════════════════════════════════════════════════════════╣
║  完成阶段: speckit.specify                              ║
║  产出物: .specify/specs/feature-x/spec.md              ║
║  ────────────────────────────────────────────────────  ║
║  压缩动作:                                              ║
║  ├── 需求澄清对话 → 压缩为摘要                          ║
║  ├── spec.md → 保留完整（作为后续锚点）                  ║
║  └── 决策卡片 → 保留最新一份                            ║
║  ────────────────────────────────────────────────────  ║
║  上下文释放: ~[X]K tokens                               ║
╚════════════════════════════════════════════════════════╝
```

---

## 集成点 4：Sub-agent 隔离建议

### 何时建议使用 Sub-agent 隔离

| 场景 | 建议 |
|------|------|
| 权重 ≥ 10 且子任务 ≥ 5 | 建议拆分到独立会话 |
| 任务涉及 3+ 完全不同的技术栈 | 建议按技术栈隔离 |
| 单会话已压缩 2+ 次仍超限 | 强烈建议拆分 |

### 隔离策略

```
主会话（Coordinator）
├── 保持：目标、计划、进度追踪
├── 产出：SESSION.md、implementation_plan.md
└── 职责：综合、决策、验收

子会话 A（Worker）
├── 输入：子任务描述 + 必要上下文
├── 产出：代码 + 执行摘要
└── 隔离：独立上下文，完成后返回摘要

子会话 B（Worker）
├── 输入：子任务描述 + 必要上下文
├── 产出：代码 + 执行摘要
└── 隔离：独立上下文，完成后返回摘要
```

### 隔离建议输出

```
╔════════════════════════════════════════════════════════╗
║  🔀 Sub-agent 隔离建议                                  ║
╠════════════════════════════════════════════════════════╣
║  当前任务复杂度: 权重 [X]，子任务 [N] 个                 ║
║  当前上下文状态: [健康 / 接近饱和 / 已饱和]              ║
║  ────────────────────────────────────────────────────  ║
║  建议: [继续当前会话 / 考虑拆分 / 强烈建议拆分]          ║
║  ────────────────────────────────────────────────────  ║
║  若拆分，建议划分:                                       ║
║  ├── 子会话 1: [子任务描述]                              ║
║  ├── 子会话 2: [子任务描述]                              ║
║  └── 主会话保留: 协调 + 验收                             ║
╚════════════════════════════════════════════════════════╝
```

---

## 与现有规则的关系

| 现有规则 | Context Engineering 增强 |
|---------|-------------------------|
| `workflow-orchestrator` | 增加 Step 0 上下文健康检查 |
| `task-weight.md` | 无变化（权重系统保持不变） |
| `knowledge-evolution.md` | 压缩时保留 Evolution Marker |
| `SESSION.md` | 作为外部记忆的核心锚点 |

---

## 实施优先级

| 优先级 | 功能 | 收益 |
|--------|------|------|
| P0 | 退化信号检测 | 防止长对话失控 |
| P1 | Spec-Kit 阶段性压缩 | 自然释放上下文 |
| P2 | 压缩摘要格式 | 保留关键锚点 |
| P3 | Sub-agent 隔离建议 | 处理超大任务 |

---

## 关联技能

| 技能 | 关系 |
|------|------|
| `context-fundamentals` | 理论基础 |
| `context-degradation` | 退化模式识别 |
| `context-compression` | 压缩策略细节 |
| `context-optimization` | 优化技术 |
| `multi-agent-patterns` | Sub-agent 隔离模式 |
| `workflow-orchestrator` | 主编排层 |
| `speckit.*` | 执行层 |

---

**Version**: 1.0.0 | **Created**: 2026-01-12 | **Author**: domiyoung
