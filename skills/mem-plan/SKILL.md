---
name: mem-plan
description: 创建 LLM 友好的分阶段计划，可在新上下文中连续执行
globs:
  - "**/*"
  - ".planning/**/*"
---

# Make Plan

**创建 LLM 友好的分阶段计划**

计划应该可以在新的聊天上下文中连续执行各个阶段。

---

## 委派模型

子代理可能报告不完整，因此：

| 角色 | 职责 |
|------|------|
| **子代理** | 事实收集和提取（文档、示例、签名、grep 结果） |
| **编排器** | 综合和计划编写（阶段边界、任务框架、最终措辞） |

如果子代理报告不完整或缺乏证据，编排器必须用针对性的读取/grep 重新检查后再最终确定计划。

---

## 子代理报告合同（强制）

每个子代理响应必须包含：

1. **咨询的来源**：文件/URL 以及读取的内容
2. **具体发现**：精确的 API 名称/签名；精确的文件路径/位置
3. **可复制的代码片段位置**：示例文件/部分
4. **置信度说明**：已知差距（可能仍然缺失的内容）

> 如果子代理报告结论但没有来源，**拒绝并重新部署**

---

## 计划结构要求

### Phase 0: 文档发现（始终第一步）

在规划实现之前，你必须：

部署 "Documentation Discovery" 子代理：
1. 搜索并阅读相关文档、示例和现有模式
2. 识别可用的实际 API、方法和签名（不是假设的）
3. 创建简短的"允许的 API"列表，引用具体文档来源
4. 注明要避免的反模式（不存在的方法、已弃用的参数）

然后编排器将发现整合为单一的 Phase 0 输出。

### 每个实现阶段必须包含

| 项目 | 说明 |
|------|------|
| **要实现什么** | 框架任务为从文档复制，而非转换现有代码 |
| **文档引用** | 引用要遵循的模式的具体文件/行 |
| **验证清单** | 如何证明此阶段有效（测试、grep 检查） |
| **反模式防护** | 不要做什么（发明的 API、未文档化的参数） |

**好的任务框架**：
```
✅ "从 docs/examples.ts:45-60 复制 V2 会话模式"
```

**坏的任务框架**：
```
❌ "将现有代码迁移到 V2"
```

### 最终阶段: 验证

1. 验证所有实现匹配文档
2. 检查反模式（grep 已知坏模式）
3. 运行测试确认功能

---

## 关键原则

| 原则 | 说明 |
|------|------|
| **文档可用性 ≠ 使用** | 明确要求阅读文档 |
| **任务框架很重要** | 引导代理到文档，而非仅仅结果 |
| **验证 > 假设** | 要求证明，不假设 API |
| **会话边界** | 每个阶段应独立，有自己的文档引用 |

---

## 要预防的反模式

- ❌ 发明"应该存在"的 API 方法
- ❌ 添加不在文档中的参数
- ❌ 跳过验证步骤
- ❌ 不检查示例就假设结构

---

## 输出格式

```markdown
# 实现计划: [功能名称]

## Phase 0: 文档发现
- 允许的 API: ...
- 反模式: ...

## Phase 1: [阶段名称]
- 要实现: ...
- 文档引用: `file:line`
- 验证清单: ...
- 反模式防护: ...

## Phase N: 验证
- 文档匹配检查
- 反模式 grep
- 测试运行
```
