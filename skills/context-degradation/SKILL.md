# Context 退化模式

> 语言模型随上下文长度增加展现可预测的退化模式。理解这些模式对于诊断故障和设计弹性系统至关重要。

---

## 触发条件

Use when:
- Agent 在长对话中性能意外下降
- 调试 Agent 产生错误或无关输出的情况
- 设计必须可靠处理大上下文的系统
- 调查 Agent 输出中的 "lost in middle" 现象

触发词：diagnose context problems, fix lost-in-middle, debug agent failures, context poisoning, 上下文退化

---

## 五种退化模式

### 1. Lost-in-Middle（中间丢失）

**现象**：U 形注意力曲线，中间信息召回率下降 10-40%

```
注意力分布:
高 ████████░░░░░░░░░░░░░████████ 高
   开头      中间（低）      结尾
```

**原因**：
- 模型对第一个 token 分配大量注意力（"注意力沉降"）
- 有限注意力预算被稀释

**缓解**：
- 关键信息放在开头或结尾
- 使用摘要结构将关键信息浮现到注意力有利位置
- 使用显式章节标题帮助导航

### 2. Context Poisoning（上下文污染）

**现象**：幻觉/错误进入上下文后通过重复引用复合

```
错误信息 → 被当作真实 → 后续决策引用 → 强化错误假设
```

**入口路径**：
- 工具输出包含错误或意外格式
- 检索文档包含不正确/过时信息
- 模型生成的摘要引入幻觉

**症状检测**：
- 之前成功的任务输出质量下降
- Agent 调用错误工具或参数
- 尽管尝试纠正，幻觉仍然持续

**恢复策略**：
- 截断上下文到污染点之前
- 显式标注污染并请求重新评估
- 用干净上下文重启，仅保留已验证信息

### 3. Context Distraction（上下文分心）

**现象**：模型过度关注提供的信息，牺牲训练知识

```
无关文档数量 ↑ → 相关任务性能 ↓
```

**关键洞察**：
- 即使单个无关文档也会降低性能
- 模型没有"跳过"无关上下文的机制
- 无关信息与相关信息竞争有限注意力

**缓解**：
- 加载检索文档前应用相关性过滤
- 使用命名空间和组织使无关部分在结构上易于忽略
- 考虑信息是否真需要在上下文中，或可通过工具调用访问

### 4. Context Confusion（上下文混淆）

**现象**：无关信息以降低质量的方式影响响应

**表现**：
- 响应解决查询的错误方面
- 工具调用看起来适合不同任务
- 输出混合来自多个来源的要求

**架构解决方案**：
- 显式任务分段：不同任务获得不同上下文窗口
- 任务上下文之间的清晰过渡
- 隔离不同目标上下文的状态管理

### 5. Context Clash（上下文冲突）

**现象**：累积信息直接矛盾，产生相互冲突的指导

**来源**：
- 多源检索中不同来源有矛盾信息
- 版本冲突：过时和当前信息同时出现
- 视角冲突：不同有效但不兼容的观点

**解决方法**：
- 显式冲突标记：识别矛盾并请求澄清
- 优先级规则：建立哪个来源优先
- 版本过滤：从上下文排除过时信息

---

## 模型特定退化阈值

| 模型 | 退化开始 | 严重退化 | 备注 |
|------|----------|----------|------|
| GPT-4o | ~64K tokens | ~128K | 思考模式下退化阻力最佳 |
| Claude 3.5 Sonnet | ~80K tokens | ~150K | 为 Agent 和编码任务优化 |
| Claude 3 Opus | ~100K tokens | ~180K | 200K 上下文窗口 |
| Gemini 1.5 Pro | ~500K tokens | ~800K | 1M 上下文窗口 |

**反直觉发现**：
- 打乱的 haystack 比连贯的表现更好（连贯上下文可能创建虚假关联）
- 单个干扰项有超大影响（存在任何干扰项即触发退化）
- needle-question 相似度低时退化更快

---

## 四桶策略（Four-Bucket Approach）

| 策略 | 说明 | 解决问题 |
|------|------|----------|
| **Write** | 将上下文保存到窗口外（scratchpad、文件系统） | 保持活跃上下文精简 |
| **Select** | 通过检索/过滤将相关上下文拉入窗口 | 排除无关信息 |
| **Compress** | 通过摘要/抽象减少 token 同时保留信息 | 扩展有效上下文容量 |
| **Isolate** | 跨 sub-agent 或会话分割上下文 | 防止单一上下文过大 |

---

## 监控与检测

```yaml
# 退化监控示例
turn_1: 1000 tokens
turn_5: 8000 tokens
turn_10: 25000 tokens
turn_20: 60000 tokens  # ⚠️ 退化开始
turn_30: 90000 tokens  # 🔴 显著退化
```

**信号**：
- 上下文利用率 > 70%
- 响应质量随对话延长下降
- 成本因长上下文增加
- 延迟随对话长度增加

---

## 指导原则

1. 开发期间监控上下文长度与性能的相关性
2. 关键信息放在开头或结尾
3. 在退化变严重前实施压缩触发器
4. 添加到上下文前验证检索文档的准确性
5. 使用版本控制防止过时信息导致冲突
6. 分段任务以防止跨不同目标的上下文混淆
7. 为优雅退化设计，而非假设完美条件
8. 用逐步增大的上下文测试以找到退化阈值

---

## 关联技能

| 技能 | 关系 |
|------|------|
| `context-fundamentals` | 基础概念 |
| `context-optimization` | 缓解技术 |
| `context-compression` | 压缩策略 |
| `multi-agent-patterns` | 使用隔离防止退化 |

---

**Version**: 1.0.0 | **Created**: 2026-01-12 | **Author**: domiyoung
