---
name: workflow-orchestrator
description: |
  工作流编排器 - 任务权重评估与分发。
  Use when:
  - 每个任务开始时自动执行
  - 计算任务权重、选择工作流
  - 路由到对应 Skill
  触发词：任务开始、权重评估、工作流选择
  Related Skills: speckit.specify, planning-with-files, brainstorm
---

# Workflow Orchestrator（工作流编排器）

> **Skill 类型**：Workflow-based（流程型）
> **核心理念**：每个任务都是一次决策树遍历。不是"想到什么做什么"，而是"系统化评估 → 选择路径 → 执行"。

---

## 🔴 强制规则（全局生效，无例外）

### 1. 任何项目、任何任务 → 必须先输出决策卡片

**无论项目是否有 CLAUDE.md，收到任务后第一步必须输出：**

```
╔════════════════════════════════════════════════════════╗
║  📊 任务权重分析                                        ║
╠════════════════════════════════════════════════════════╣
║  任务描述: [一句话描述]                                  ║
║  权重得分: [X] 分                                       ║
║  工作流: [Spec-Kit / planning-with-files / TodoWrite]   ║
║  触发 Skills: [列出将使用的 skills]                      ║
╚════════════════════════════════════════════════════════╝
```

### 2. 新项目处理流程

即使项目没有 `CLAUDE.md`，也必须：
1. 加载 `~/.claude/CLAUDE.md` 全局配置
2. 执行权重评估
3. 输出决策卡片
4. 使用 `smart-commit` 格式提交代码

### 3. 执行前自检循环（Pre-Execution Checkpoint）⭐ NEW

> **核心原则**：阻塞优于建议。未通过自检 = 禁止执行。

**在执行任何实际工作之前，必须通过以下自检：**

```
╔════════════════════════════════════════════════════════╗
║  🛡️ PRE-EXECUTION CHECKPOINT                           ║
╠════════════════════════════════════════════════════════╣
║  □ 决策卡片已输出？        [YES/NO]                     ║
║  □ Forced Eval 已完成？    [YES/NO]                     ║
║  □ 工作流已选择？          [YES/NO]                     ║
║  ────────────────────────────────────────────────────  ║
║  ⚠️ 任一 NO = 禁止执行，必须先补充                      ║
╚════════════════════════════════════════════════════════╝
```

**自检时机**：
- 准备调用任何写入工具（Edit/Write/Bash）之前
- 准备生成代码之前
- 准备执行任何修改操作之前

**自检失败处理**：
1. **立即停止**当前操作
2. **补输出**缺失的决策卡片/Forced Eval
3. **重新评估**后再继续

### 4. 递归强化机制（Recursive Reinforcement）

> **对抗指令衰减**：显式输出 = 保持在上下文 = 不会被遗忘

**触发条件**：
- 每 10 轮对话：重新输出当前任务的决策卡片摘要
- 检测到任何退化信号：强制重新评估
- 阶段切换时：输出阶段转换卡片

**退化信号检测**：
| 信号 | 自我检测方式 |
|------|-------------|
| 重复询问已回答的问题 | 检查历史对话 |
| 跳过决策卡片 | Pre-Execution Checkpoint 失败 |
| 工具调用错误增加 | 检测错误率上升 |

### 5. 违规自检（被动防线）

如果发现自己跳过了决策卡片直接执行任务：
1. 立即停止
2. 补输出决策卡片
3. 重新按流程执行
4. **记录违规**：在输出中标注 `⚠️ 流程违规已修正`

---

## Quick Start

```
收到任务 → Step 0: 上下文健康检查 → Step 1: 权重分析 → Step 2: 发散检测 → Step 3: 选择工作流 → Step 3.5: 迭代执行模式（可选） → Step 4: Skill 路由 → Step 4.2: Skill 读取+证据卡片 → Step 4.5: 知识库检索 → Step 5: 执行/验证 → Step 6: 知识回写
```

**必须输出决策卡片**，然后再开始实际工作。

---

## Step 0: 上下文健康检查（长对话保护）

> **为什么需要**：长对话中指令会衰减，决策卡片是对抗衰减的锚点。
> **理论基础**：参见 `rules/context-aware-orchestration.md`

### 触发条件

| 条件 | 检查动作 |
|------|----------|
| 对话轮次 > 20 | 输出健康检查卡片 |
| 感知到退化信号 | 触发压缩协议 |
| Spec-Kit 阶段切换 | 阶段性压缩 |

### 退化信号识别

| 信号 | 表现 | 严重度 |
|------|------|--------|
| 忘记之前决策 | 重复询问已回答的问题 | 🔴 高 |
| 跳过决策卡片 | 直接执行未经评估 | 🔴 高 |
| 工具调用错误增加 | 参数错误、调用错工具 | 🟡 中 |
| 混淆任务边界 | 把不同任务内容混在一起 | 🟡 中 |

### 健康检查输出（仅长对话时输出）

```
╔════════════════════════════════════════════════════════╗
║  🏥 上下文健康检查                                      ║
╠════════════════════════════════════════════════════════╣
║  对话轮次: [N]                                          ║
║  退化信号: [无 / 轻微 / 明显]                            ║
║  建议动作: [继续 / 压缩历史 / 建议新会话]                ║
╚════════════════════════════════════════════════════════╝
```

### 压缩时必须保留的锚点

```yaml
永不压缩:
  - 最近一次决策卡片
  - 当前任务的权重评估结果
  - SESSION.md 中的目标锚点
  - 未完成的 TODO 项
  - 最近 3 轮对话

可压缩:
  - 早期探索性对话
  - 已完成任务的详细过程
  - 工具输出的完整内容（保留摘要）
```

### 与后续步骤的关系

```
Step 0 通过 → 继续 Step 1 权重分析
Step 0 需干预 → 先压缩/恢复锚点 → 再 Step 1
```

---

## 三层架构

```
┌─────────────────────────────────────────────────────────────────┐
│ Layer 1: 硬约束层（必须遵守）                                    │
│ └── user_global + Hook → 强制执行                               │
├─────────────────────────────────────────────────────────────────┤
│ Layer 2: 编排层（本 Skill）                                      │
│ └── workflow-orchestrator → 权重计算、路由决策                   │
├─────────────────────────────────────────────────────────────────┤
│ Layer 3: 能力层（统一使用 Skills）                               │
│ ├── brainstorm → 脑暴/多方案对比（原 SuperClaude 能力）          │
│ ├── spec-first → Spec-Kit 流程                                  │
│ └── 领域 Skills → mermaid-expert, frontend-expert 等            │
└─────────────────────────────────────────────────────────────────┘
```

---

## 统一 Skills 系统

> **核心变更**：SuperClaude 的核心能力已整合到 `brainstorm` Skill，现在**只使用 Skills 系统**。
> **触发机制**：使用 **Forced Eval Protocol** + **AI 语义判断**，而非硬编码关键词。

| Skill | 触发条件（AI 语义判断） | 输出 |
|-------|----------------------|------|
| **brainstorm** | 意图分类为 explore/decide | 多方案对比、专家会诊 |
| **spec-first** | 权重 ≥7 | implementation_plan.md |
| **planning-with-files** | 多步骤任务 | task_plan.md、notes.md |
| **领域 Skills** | AI 识别任务领域 | 具体 SOP 执行 |

### 调用逻辑（Forced Eval Protocol）

```
Step 1: 意图分类（AI 语义判断）
    → explore/decide → brainstorm Skill
    → execute/clarify → 继续下一步

Step 2: 权重评估
    → 权重 ≥ 7 → spec-first Skill
    → 权重 3-6 → planning-with-files
    → 权重 1-2 → Direct

Step 3: Skill 强制评估（必须输出 YES/NO）
    → 对每个可能适用的 Skill 进行显式评估
    → 形成"承诺机制"，防止执行衰减
```

---

## Decision Tree（决策树）

```
                    ┌─────────────────┐
                    │   收到新任务     │
                    └────────┬────────┘
                             ▼
                    ┌─────────────────┐
                    │ Step 1: 权重分析 │
                    └────────┬────────┘
                             ▼
              ┌──────────────┴──────────────┐
              ▼                              ▼
     ┌────────────────┐            ┌────────────────┐
     │ 权重 ≥ 7       │            │ 权重 < 7       │
     │ → Spec-Kit     │            │                │
     └────────┬───────┘            └────────┬───────┘
              ▼                              ▼
     ┌────────────────┐            ┌────────────────┐
     │ Step 2: 发散检测│            │ Step 2: 发散检测│
     └────────┬───────┘            └────────┬───────┘
              ▼                              ▼
     ┌────────────────┐            ┌────────────────┐
     │ 触发脑暴?      │            │ 触发脑暴?      │
     │ → brainstorm   │            │ → 或直接执行   │
     └────────┬───────┘            └────────┬───────┘
              ▼                              ▼
     ┌────────────────┐            ┌────────────────┐
     │ Step 4: 路由    │            │ Step 4: 路由   │
     │ → 匹配专家 Skill│            │ → 或 Direct    │
     └────────────────┘            └────────────────┘
```

---

## Step 1: 权重分析（必须输出）

### 输出格式

```
╔════════════════════════════════════════════════════════╗
║  📊 任务权重分析                                        ║
╠════════════════════════════════════════════════════════╣
║  触发条件                        │  权重  │  命中       ║
╠──────────────────────────────────┼────────┼────────────╣
║  新功能 / 重构 / Breaking Change │  +10   │  [ ]       ║
║  >5 文件 或 >200 行              │  +8    │  [ ]       ║
║  API/架构/Schema 变更            │  +7    │  [ ]       ║
║  3-5 文件功能变更                │  +5    │  [ ]       ║
║  简单 Bug（<3 文件）             │  +2    │  [ ]       ║
║  纯样式/文档                     │  +1    │  [ ]       ║
╠──────────────────────────────────┴────────┴────────────╣
║  📈 总权重: [X]                                         ║
║  🎯 工作流: [Spec-Kit / Task-Only / Direct]            ║
╚════════════════════════════════════════════════════════╝
```

### 判断规则

| 总权重 | 工作流 | 动作 | 出错处理 |
|--------|--------|------|---------|
| **≥7** | Spec-Kit | 必须创建 implementation_plan.md → 用户审批 | 若无法判断权重，询问用户 |
| **5-6** | Spec-Kit（建议） | 默认进入，可被用户跳过 | 若用户说"跳过"则走 Task-Only |
| **3-4** | Task-Only | 创建 task.md 跟踪 | 若超出预期复杂度，升级到 Spec-Kit |
| **1-2** | Direct | 直接执行 | 若发现隐藏复杂度，暂停并重新评估 |

---

## Step 1.5: 思考深度选择（Think 升级链）

> **核心理念**：根据任务复杂度自动选择合适的思考深度，避免简单问题过度思考，复杂问题思考不足。

### 自动选择规则

| 权重 | 思考深度 | Token 预算 | 触发关键词 |
|------|---------|-----------|-----------|
| 1-2 | `think` | ~4K | 默认 |
| 3-4 | `think hard` | ~10K | 自动 |
| 5-6 | `think harder` | ~20K | 自动 |
| ≥7 | `ultrathink` | ~32K | 自动或用户指定 |

### 输出格式

```
╔════════════════════════════════════════════════════════╗
║  🧠 思考深度选择                                        ║
╠════════════════════════════════════════════════════════╣
║  任务权重: [X]                                          ║
║  推荐深度: [think/think hard/think harder/ultrathink]  ║
║  理由: [为什么选择这个深度]                              ║
╚════════════════════════════════════════════════════════╝
```

### 探索优先模式

**复杂任务（权重 ≥5）必须先探索，禁止直接动手**：

```bash
# ✅ 正确做法：先理解再动手
"Read the [相关目录] and summarize how [功能] works.
 Don't write any code yet."

# ❌ 错误做法：直接开始写代码
"看看代码然后修复问题"
```

**探索优先工作流**：
```
Explore（读懂）→ Plan（想清楚）→ Code（小步迭代）→ Commit（自动提交）
```

---

## Step 2: 发散性思维检测（Forced Eval Protocol）

> **核心原则**：使用 AI 语义判断 + 强制输出，而非硬编码关键词匹配。
> **为什么这样设计**：
> - 关键词匹配覆盖不全，容易遗漏边缘情况
> - 多轮对话后指令衰减，需要"承诺机制"强化
> - 社区验证：Forced Eval Hook 成功率 84%（vs 简单指令 20%）

### 2.1 意图分类（AI 语义判断）

**不使用关键词匹配，而是分析用户请求的真实意图**：

| 意图类型 | 特征描述 | 触发脑暴 | 示例 |
|---------|---------|---------|------|
| **explore** | 寻求多种可能方案、开放式问题 | ✅ YES | "这个功能有几种实现方式？" |
| **decide** | 在已知方案中选择、需要对比分析 | ✅ YES | "A 和 B 哪个更适合？" |
| **execute** | 目标明确、方案已定、直接实施 | ❌ NO | "实现用户登录功能" |
| **clarify** | 理解问题、收集信息、不涉及方案 | ❌ NO | "这段代码是做什么的？" |

### 2.2 强制评估输出（Forced Eval - 必须执行）

> **"If it's not in the output, it won't stay in context. If it's not in context, it gets forgotten."**
> 如果不在输出中，就不会留在上下文；不在上下文，就会被遗忘。

**必须输出以下评估卡片，形成"承诺机制"：**

```
╔════════════════════════════════════════════════════════╗
║  🔍 FORCED EVAL: 发散性思维检测                         ║
╠════════════════════════════════════════════════════════╣
║  用户请求: [一句话摘要]                                  ║
║  ────────────────────────────────────────────────────  ║
║  意图分类: [explore / decide / execute / clarify]      ║
║  判断理由: [为什么是这个分类，基于语义而非关键词]         ║
║  ────────────────────────────────────────────────────  ║
║  🧠 触发脑暴: [YES / NO]                                ║
║  → 若 YES: 激活 brainstorm Skill                        ║
║  → 若 NO: 继续 Step 3 工作流选择                        ║
╚════════════════════════════════════════════════════════╝
```

### 2.3 判断标准（给 Claude 的指引）

**explore 的识别信号**：
- 用户没有预设答案，期待 Claude 提供多个选项
- 问题是开放式的，没有唯一正确答案
- 用户在做决策前需要了解可能性

**decide 的识别信号**：
- 用户已知几个选项，需要帮助选择
- 需要对比分析、权衡利弊
- 用户说"哪个更好"、"应该选哪个"

**execute 的识别信号**：
- 用户目标明确，知道要做什么
- 不需要探索替代方案
- 用户说"帮我实现"、"修复这个"

**clarify 的识别信号**：
- 用户在寻求理解，不是请求行动
- 用户说"解释一下"、"为什么"、"是什么意思"

### 2.4 触发后动作

**若触发脑暴（explore/decide）**：
1. 激活 `brainstorm` Skill
2. 输出至少 3 个备选方案
3. 进行优劣对比表格
4. 给出推荐方案及理由
5. 等待用户选择后，回到 Step 1 重新评估权重

### 2.5 递归强化规则

为防止多轮对话后执行衰减：
- **每个新任务**必须输出完整的 Forced Eval 卡片
- 判断结果**显式写入输出**，保持在活跃上下文中
- 若检测到可能遗漏，主动询问："这个任务是否需要探索多种方案？"

---

## Step 3: 工作流选择

| 条件 | 工作流 | 执行步骤 |
|------|--------|---------|
| 权重 ≥7 | **Spec-Kit（自动串联）** | 自动执行: speckit.constitution → speckit.specify → speckit.plan → speckit.tasks → speckit.implement |
| 发散性思维 ✓ | **Brainstorm** | 脑暴 → 方案对比 → 用户选择 → 再评估权重 |
| 权重 5-6 | **planning-with-files** | 创建 .planning/task_plan.md → 执行 → 更新 |
| 权重 3-4 | **planning-with-files-lite** | 仅 task_plan.md → 执行 |
| 权重 1-2 | **TodoWrite** | 直接执行 |

### Spec-Kit 自动串联流程（权重≥7 时自动执行）

```
权重 ≥7 检测到
      │
      ▼
┌─────────────────────────────────────────────────────────┐
│  1. speckit.constitution → 读取/更新项目宪法             │
│  2. speckit.specify → 生成功能规范                       │
│  3. speckit.clarify → 澄清不明确需求（如需要）           │
│  4. speckit.plan → 生成实现计划                          │
│  5. speckit.tasks → 任务分解                             │
│  6. speckit.implement → 执行实现                         │
│  7. speckit.checklist → 验收检查清单                     │
└─────────────────────────────────────────────────────────┘
```

> **注意**: 用户说「跳过 Spec-Kit」「直接开始」时可跳过自动串联。

---

## Step 3.5: 迭代执行模式（Ralph Loop，可选）

> **定位**：当任务目标明确、验证标准可自动化时，用迭代循环加速收敛。

**适用条件**：
- 需求清晰、完成标准可量化（测试/脚本/验收清单）
- 允许多轮自动迭代（无需频繁人类决策）

**不适用**：
- 探索性/开放式问题
- 需要频繁人类判断的设计类任务

**使用方式**：
```
/ralph-loop "<PROMPT>" --max-iterations 20 --completion-promise "DONE"
```

**要求**：
- PROMPT 内必须写清完成标准
- 必须设置 `--max-iterations` 防止死循环

---

## Step 4: Skill 自动路由（Forced Eval Protocol）

### 路由机制（AI 语义判断 + 强制评估）

> **不再使用关键词匹配**，而是让 Claude 根据任务语义自动识别适用的 Skill。
> 📖 **路由表参考**: [ROUTING_TABLE.md](./ROUTING_TABLE.md) - 完整覆盖 46 个 Skills。

### 1% 原则

> **如果有 1% 的可能性某个 skill 适用，必须调用它。**

### Skill 强制评估输出（必须执行）

**对可能适用的 Skill 进行显式 YES/NO 评估：**

```
╔════════════════════════════════════════════════════════╗
║  🎯 FORCED EVAL: Skill 路由                             ║
╠════════════════════════════════════════════════════════╣
║  任务领域识别: [前端/后端/架构/数据/全栈/其他]           ║
║  ────────────────────────────────────────────────────  ║
║  Skill 评估:                                            ║
║  ├── brainstorm:    [YES/NO] - 理由: ___               ║
║  ├── spec-first:    [YES/NO] - 理由: ___               ║
║  ├── reactflow:     [YES/NO] - 理由: ___               ║
║  ├── zustand:       [YES/NO] - 理由: ___               ║
║  ├── [其他相关]:    [YES/NO] - 理由: ___               ║
║  ────────────────────────────────────────────────────  ║
║  🎯 激活 Skill: [skill-name] (可多个)                   ║
║  📁 Skill 路径: ~/.claude/skills/[skill-name]/SKILL.md  ║
╚════════════════════════════════════════════════════════╝
```

### 语义识别指引

**前端领域识别信号**:
- 涉及 React/Vue/组件/UI/样式/动画/响应式
- 用户界面交互、表单处理、状态管理

**后端领域识别信号**:
- 涉及 API/数据库/服务端/认证/缓存
- 数据处理、业务逻辑、接口设计

**架构领域识别信号**:
- 涉及系统设计/模式/SOLID/重构/技术选型
- 跨模块协调、性能优化、可扩展性

**特定技术识别信号**:
- ReactFlow: 节点、连线、Handle、工作流编辑器
- Zustand: 状态管理、store、全局状态
- SignalR: 实时通信、WebSocket、消息推送
- Mermaid: 流程图、时序图、架构图

## Step 4.2: Skill 读取 + 证据卡片（强制）

> **目的**：让用户看到“真实读取了哪些 Skill”，防止只口头提及。

### 执行规则
1. **先读后说**：每个激活 Skill 必须先读取 `SKILL.md`。
2. **多 Skill → 调用 skill-composer**：如果激活 ≥2 个 Skill，必须先调用 `skill-composer` 规划顺序。
3. **输出证据卡片**：列出已读文件 + 可定位锚点（标题/小节/反模式名）。
4. **未读则标记 MISSING**：严禁虚构证据。

### 证据卡片模板（使用 tool-activation-banner 规范）

```
╔═══════════════════════════════════════════════════════╗
║  🔍 SKILL 调用链（证据）                               ║
╠═══════════════════════════════════════════════════════╣
║  任务/症状: [一句话描述]                               ║
║  主 Skill: [skill] ✅ 已读取                           ║
║  协作 Skill: [skill] ✅ 已读取                         ║
║  读取证据:                                            ║
║   - [path]/SKILL.md → [小节/规则/反模式标题]           ║
║   - [path]/references/xxx.md → [小节标题]             ║
╚═══════════════════════════════════════════════════════╝
```

---

## Step 4.5: 知识库检索（makepad-skills 结构）

> **知识库唯一来源**：Skills SKILL.md（分层存储）。

**优先级**：
1. `skills/_base/`（官方/稳定模式）
2. `skills/community/`（个人积累/演化中）
3. 回退：`skills/<skill-name>/SKILL.md`

**执行要求**：
- 先读相关 Skill 的规则/反模式/最佳实践，再动手
- 若发现缺失规则，进入 Step 6 回写

---

## Error Handling（出错处理）

| 场景 | 检测方式 | 处理方式 |
|------|---------|---------|
| **无法判断权重** | 信息不足以计算 | 询问用户补充信息：涉及文件数？是否新功能？ |
| **权重评估错误** | 执行中发现复杂度远超预期 | 暂停 → 重新评估 → 可能升级工作流 |
| **Skill 匹配失败** | 无关键词命中 | 使用默认工作流，不强制路由 |
| **用户要求跳过** | 输入包含"跳过"、"直接" | 记录跳过原因，直接执行 |
| **发散变收敛** | 脑暴后用户选定方案 | 回到 Step 1 重新评估选定方案的权重 |

---

## Skip Conditions（豁免条件）

以下情况可跳过决策卡片：
- 用户明确说："跳过评估"、"直接开始"、"skip"、"继续"
- 纯问答对话（非任务执行）
- 延续上一轮已评估的任务

---

## Examples（示例 - Forced Eval Protocol）

### 示例 1：复杂功能（execute + 高权重）

**用户**："帮我实现用户登录功能，包括 OAuth、邮箱验证、记住我"

```
╔════════════════════════════════════════════════════════╗
║  📊 任务权重分析                                        ║
╠──────────────────────────────────┼────────┼────────────╣
║  新功能 / 重构 / Breaking Change │  +10   │  [x]       ║
║  >5 文件 或 >200 行              │  +8    │  [x]       ║
║  API/架构/Schema 变更            │  +7    │  [x]       ║
╠──────────────────────────────────┴────────┴────────────╣
║  📈 总权重: 25                                          ║
║  🎯 工作流: Spec-Kit（强制）                            ║
╚════════════════════════════════════════════════════════╝

╔════════════════════════════════════════════════════════╗
║  🎯 Skill 路由                                          ║
║  触发 Skill: senior-architect + backend-expert         ║
╚════════════════════════════════════════════════════════╝

正在创建 implementation_plan.md...
```

### 示例 2：发散性思维（explore）

**用户**："这个功能有几种实现方式？哪种更好？"

```
╔════════════════════════════════════════════════════════╗
║  🔍 FORCED EVAL: 发散性思维检测                         ║
╠════════════════════════════════════════════════════════╣
║  用户请求: 询问功能的多种实现方式                        ║
║  意图分类: explore                                      ║
║  判断理由: 用户寻求多方案对比，"哪种更好"表明未做决定    ║
║  🧠 触发脑暴: YES → 激活 brainstorm Skill               ║
╚════════════════════════════════════════════════════════╝

🧠 启动 brainstorm Skill...

## 方案对比

| 方案 | 优势 | 劣势 | 推荐场景 |
|------|------|------|---------|
| A: ... | ... | ... | ... |
| B: ... | ... | ... | ... |
| C: ... | ... | ... | ... |

**推荐**: 方案 A，因为...
```

### 示例 3：简单修复

**用户**："修复按钮颜色问题"

```
╔════════════════════════════════════════════════════════╗
║  📊 任务权重分析                                        ║
║  纯样式/文档                     │  +1    │  [x]       ║
║  📈 总权重: 1                                           ║
║  🎯 工作流: Direct                                      ║
╚════════════════════════════════════════════════════════╝

直接执行修复...
```

---

## Critical Guidelines（关键准则）

1. **必须先输出决策卡片** - 这不是建议，是强制要求
2. **权重决定一切** - 严格按权重选择工作流
3. **发散优先收敛** - 检测到发散性思维时，先脑暴再执行
4. **1% 原则** - 有 1% 可能适用的 Skill 必须调用
5. **可被覆盖** - 用户明确要求时可跳过
6. **出错即暂停** - 发现评估错误时暂停并重新评估
7. **证据卡片必出** - 未输出 Skill 调用链证据不得执行
8. **执行前自检** - 任何写入操作前必须通过 Pre-Execution Checkpoint

---

## SESSION.md 自动化（P - Progress 层）

> **核心理念**：每个任务都应该被追踪。SESSION.md 是人类可读的进度文档，确保上下文不丢失。

### 触发时机

| 时机 | 动作 |
|------|------|
| **任务开始** | 检查 ./SESSION.md 是否存在 |
| **不存在时** | 从模板创建：`~/.claude/templates/SESSION.md` |
| **存在时** | 读取恢复上下文，显示上次进度 |
| **任务执行中** | 每个 Phase 完成后更新 |
| **任务结束** | 更新进度百分比、记录关键决策 |

### 自动创建流程

```
任务开始
    │
    ▼
┌─────────────────────────────────┐
│ 检查 ./SESSION.md 是否存在？     │
└─────────────────┬───────────────┘
                  │
       ┌──────────┴──────────┐
       ▼                      ▼
   ┌────────┐            ┌────────┐
   │ 不存在 │            │  存在  │
   └────┬───┘            └────┬───┘
        │                      │
        ▼                      ▼
  ┌───────────────┐    ┌───────────────┐
  │ 从模板复制创建 │    │ 读取恢复上下文 │
  └───────────────┘    └───────────────┘
        │                      │
        └──────────┬───────────┘
                   ▼
         ┌─────────────────┐
         │ 填入当前任务信息  │
         └─────────────────┘
```

### SESSION.md 关键字段更新规则

| 字段 | 更新时机 | 更新内容 |
|------|---------|---------|
| `当前状态.任务` | 任务开始 | 任务描述 |
| `当前状态.阶段` | 阶段切换 | 勾选对应阶段 |
| `当前状态.进度` | 每步完成 | 百分比 |
| `目标锚点.需求来源` | 任务开始 | spec.md / 用户请求 |
| `执行计划.当前步骤` | 执行时 | 当前正在做的事 |
| `执行计划.已完成` | 完成时 | 移动到已完成列表 |
| `上下文记忆.关键决策` | 做决策时 | 记录决策和理由 |
| `状态更新日志` | 每次变更 | 时间戳 + 描述 |

### 与 claude-mem 的关系

| 维度 | SESSION.md | claude-mem（可选） |
|------|-----------|-------------------|
| **格式** | 人类可读 Markdown | SQLite + Chroma |
| **持久化** | 文件级（需手动保存） | 自动跨会话 |
| **用途** | 进度追踪、上下文恢复 | 会话摘要/调用历史 |
| **谁读** | 人 + AI | 主要 AI |

**结论**：claude-mem 非必需，不作为知识库；知识以 Skills SKILL.md 为准。

### 示例：任务开始时的输出

```
🔄 检查 SESSION.md...
❌ 文件不存在，从模板创建...

📋 SESSION.md 已初始化：
┌─────────────────────────────────────────────────────┐
│ 📍 当前状态                                          │
│ ────────────────────────────────────────────────── │
│ 任务: 修复迭代节点子节点不显示的问题                   │
│ 阶段: [x] 分析 → [ ] 设计 → [ ] 实现 → [ ] 验证     │
│ 进度: 10%                                           │
│ ────────────────────────────────────────────────── │
│ 🎯 目标锚点                                          │
│ 需求来源: 用户请求                                   │
│ 成功标准:                                           │
│   - [ ] 子节点添加后正确显示                         │
│   - [ ] 连线正确生成                                 │
└─────────────────────────────────────────────────────┘

继续执行任务...
```

### 示例：恢复上下文时的输出

```
🔄 检查 SESSION.md...
✅ 文件存在，恢复上下文...

📋 上次进度：
┌─────────────────────────────────────────────────────┐
│ 任务: 修复迭代节点子节点不显示的问题                   │
│ 进度: 60%                                           │
│ 阶段: [x] 分析 → [x] 设计 → [ ] 实现 → [ ] 验证     │
│ ────────────────────────────────────────────────── │
│ 已完成:                                              │
│   - [x] 定位问题根因                                 │
│   - [x] 设计修复方案                                 │
│ 当前步骤:                                            │
│   - [ ] 实现 updateNodeInternals 修复               │
└─────────────────────────────────────────────────────┘

从「实现」阶段继续...
```

---

## Step 6: 知识进化集成

任务完成后，使用**知识识别四问**判断是否记录：

```
任务完成
    │
    ▼
┌─────────────────────────────────┐
│ 知识识别四问（2+ YES = 记录）    │
│ □ 可复用？  □ 费力？            │
│ □ 有帮助？  □ 未文档化？        │
└─────────────────┬───────────────┘
                  │
       ┌──────────┴──────────┐
       ▼                      ▼
   ┌────────┐            ┌────────┐
   │ 2+ YES │            │ < 2    │
   └────┬───┘            └────┬───┘
        │                      │
        ▼                      ▼
  ┌───────────────┐    ┌───────────────┐
  │ 写入 SKILL.md │    │ 直接完成任务  │
  │ + Evolution   │    └───────────────┘
  │   Marker      │
  └───────────────┘
```

**写入路径**：
- 默认写入 `skills/community/<topic>/SKILL.md`
- 经过验证的稳定规则可上移至 `skills/_base/`

**自我修正**：
- 规则错误/过期：标记 `Deprecated` 或写入 Self-Correction 记录

→ 详见 `~/.claude/rules/knowledge-evolution.md`
